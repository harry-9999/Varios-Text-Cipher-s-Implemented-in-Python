#!/usr/bin/env python3
import os
import sys
import struct
import random
import string
from string import ascii_uppercase as l
from itertools import cycle, islice
from ctypes import c_ulong
from functools import reduce

def ulong(i): return c_ulong(i).value

def sdbm_hash(s):
  return reduce(lambda h,c: ulong(ord(c) + (h << 6) + (h << 16) - h), s, 0)

def generate_lck(password, n):
  a  = 1103515245 
  c = 12345 
  m = 256 

  seed = sdbm_hash(password) # seed generated by hashing password
  keystream_blist = []
  
  x_value = seed
  i = 0
  while(i<n):
    x_value = (a * x_value + c) % m
    keystream_blist.append( x_value )
    i = i+1
  return keystream_blist

def blocks(lst, n):
    n = max(1, n)
    return list(lst[i:i+n] for i in range(0, len(lst), n))

def swap(list, pos1, pos2): 
    list[pos1], list[pos2] = list[pos2], list[pos1] 
    return list


def sbdecrypt(password, c_f_blist, output_file):
  f = open(output_file, "wb")
  ciphertext_block_blist = []
  prev_ciphertext_block_blist = []
  temp_block_blist = []
  blocksize = 16
  keystream = generate_lck(password, (16 * (len(c_f1_blist)+1)) )
  
  # Creating 16 byte blocks
  keystream= blocks(keystream,16 )
  IV = keystream[0]
  e =  1
  p =[]
  tt = 0
  for block in c_f1_blist:
    tt = tt + 1
    ciphertext_block_blist = block.copy()
    keystream_blist = keystream[e]
    e = e + 1
    i = 0
    for i in range(blocksize): # XOR temp block with keystream block
      keystream_byte = int(keystream_blist[i])
      if (isinstance(ciphertext_block_blist[i],int)):
        cipher_byte = ciphertext_block_blist[i]
      else:
        cipher_byte = int.from_bytes(ciphertext_block_blist[i], "big")
      v = cipher_byte ^ keystream_byte
      temp_block_blist.append(v) # Storing for next iteration     
    
    i =0
    for i in range(blocksize): # Iterating through keystream and manipulating each byte
      first = int(keystream_blist[15-i]) & int(hex(0xf), 16)
      second = ( int(keystream_blist[15-i]) >> 4) & int(hex(0xf), 16)
      temp_block_blist = swap(temp_block_blist,first,second)
         
    if ( len(prev_ciphertext_block_blist) == 0):
        prev_ciphertext_block_blist = IV.copy()
    
    i = 0 
    for i in range(blocksize): # XOR temp block with keystream block
      if (isinstance(prev_ciphertext_block_blist[i], int)):
        prev_ciphertext_byte = int(prev_ciphertext_block_blist[i])
      else:
        prev_ciphertext_byte = int.from_bytes(prev_ciphertext_block_blist[i], byteorder="big")
      temp_byte = int(temp_block_blist[i])
      v = temp_byte ^ prev_ciphertext_byte
      p.append(v)
    
    # Removing padding if last block in list
    if (tt == len(c_f_blist) ):
      end = 16 - p[-1]
      p = p[0:end]
    # Writting bytes to file
    for v in range(len(p) ):
      f.write((p[v]).to_bytes(1, 'big')) # Writing plaintext byte
  
    p = []
    temp_block_blist = []
    prev_ciphertext_block_blist = block.copy()

      

password = str(sys.argv[1])
f1_blist = []
file = open(str(sys.argv[2]), 'rb')
while True:
  byte = file.read(1)
  if not byte:
    break
  f1_blist.append(bytes(byte))


# Creating 16 byte blocks
c_f1_blist = blocks(f1_blist,16 )
sbdecrypt(password,c_f1_blist,str(sys.argv[3]))
print("program complete!")


